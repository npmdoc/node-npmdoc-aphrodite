<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/Khan/aphrodite">aphrodite (v1.2.0)</a>
</h1>
<h4>Inline styles in JS that just work (TM)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite">module aphrodite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.css">
            function <span class="apidocSignatureSpan">aphrodite.</span>css
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.ordered_elements">
            function <span class="apidocSignatureSpan">aphrodite.</span>ordered_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>StyleSheet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>StyleSheetServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>StyleSheetTestUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>generate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>inject</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>no_important</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.StyleSheet">module aphrodite.StyleSheet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheet.create">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>create
            <span class="apidocSignatureSpan">(sheetDefinition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheet.extend">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>extend
            <span class="apidocSignatureSpan">(extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheet.rehydrate">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>rehydrate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.StyleSheetServer">module aphrodite.StyleSheetServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheetServer.renderStatic">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheetServer.</span>renderStatic
            <span class="apidocSignatureSpan">(renderFunc)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.StyleSheetTestUtils">module aphrodite.StyleSheetTestUtils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheetTestUtils.clearBufferAndResumeStyleInjection">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheetTestUtils.</span>clearBufferAndResumeStyleInjection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.StyleSheetTestUtils.suppressStyleInjection">
            function <span class="apidocSignatureSpan">aphrodite.StyleSheetTestUtils.</span>suppressStyleInjection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.generate">module aphrodite.generate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.generate.generateCSS">
            function <span class="apidocSignatureSpan">aphrodite.generate.</span>generateCSS
            <span class="apidocSignatureSpan">(selector, styleTypes, selectorHandlers, stringHandlers, useImportant )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.generate.generateCSSRuleset">
            function <span class="apidocSignatureSpan">aphrodite.generate.</span>generateCSSRuleset
            <span class="apidocSignatureSpan">(selector, declarations, stringHandlers, useImportant, selectorHandlers )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.generate.</span>defaultSelectorHandlers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.inject">module aphrodite.inject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.addRenderedClassNames">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>addRenderedClassNames
            <span class="apidocSignatureSpan">(classNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.flushToString">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>flushToString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.flushToStyleTag">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>flushToStyleTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.getRenderedClassNames">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>getRenderedClassNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.injectAndGetClassName">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>injectAndGetClassName
            <span class="apidocSignatureSpan">(useImportant, styleDefinitions, selectorHandlers )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.injectStyleOnce">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>injectStyleOnce
            <span class="apidocSignatureSpan">(key, selector, definitions, useImportant )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.reset">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.inject.startBuffering">
            function <span class="apidocSignatureSpan">aphrodite.inject.</span>startBuffering
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.no_important">module aphrodite.no_important</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.no_important.css">
            function <span class="apidocSignatureSpan">aphrodite.no_important.</span>css
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.no_important.</span>StyleSheet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.no_important.</span>StyleSheetServer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">aphrodite.no_important.</span>StyleSheetTestUtils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.ordered_elements">module aphrodite.ordered_elements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.ordered_elements.ordered_elements">
            function <span class="apidocSignatureSpan">aphrodite.</span>ordered_elements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.ordered_elements.from">
            function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>from
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.ordered_elements.fromMap">
            function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>fromMap
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.ordered_elements.fromObject">
            function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.aphrodite.util">module aphrodite.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.flatten">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>flatten
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.flattenDeep">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>flattenDeep
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.hashObject">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>hashObject
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.importantify">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>importantify
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.kebabifyStyleName">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>kebabifyStyleName
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.mapObj">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>mapObj
            <span class="apidocSignatureSpan">(obj, fn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.objectToPairs">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>objectToPairs
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.recursiveMerge">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>recursiveMerge
            <span class="apidocSignatureSpan">(a, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.aphrodite.util.stringifyValue">
            function <span class="apidocSignatureSpan">aphrodite.util.</span>stringifyValue
            <span class="apidocSignatureSpan">(key, prop )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite" id="apidoc.module.aphrodite">module aphrodite</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.css" id="apidoc.element.aphrodite.css">
        function <span class="apidocSignatureSpan">aphrodite.</span>css
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function css() /* : MaybeSheetDefinition[] */{
    for (var _len = arguments.length, styleDefinitions = Array(_len), _key = 0; _key &lt; _len; _key++) {
        styleDefinitions[_key] = arguments[_key];
    }

    return (0, _inject.injectAndGetClassName)(useImportant, styleDefinitions, selectorHandlers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.ordered_elements" id="apidoc.element.aphrodite.ordered_elements">
        function <span class="apidocSignatureSpan">aphrodite.</span>ordered_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedElements() {
    var elements /* : {[string]: any} */ = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];
    var keyOrder /* : string[] */ = arguments.length &lt;= 1 || arguments[1] === undefined ? [] : arguments[1];

    _classCallCheck(this, OrderedElements);

    this.elements = elements;
    this.keyOrder = keyOrder;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.StyleSheet" id="apidoc.module.aphrodite.StyleSheet">module aphrodite.StyleSheet</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheet.create" id="apidoc.element.aphrodite.StyleSheet.create">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>create
        <span class="apidocSignatureSpan">(sheetDefinition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(sheetDefinition) {
    return (0, _util.mapObj)(sheetDefinition, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var val = _ref2[1];

        return [key, {
            // TODO(emily): Make a 'production' mode which doesn't prepend
            // the class name here, to make the generated CSS smaller.
            _name: key + '_' + (0, _util.hashObject)(val),
            _definition: val
        }];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            This is blue and turns red when the browser is less than
            600px width.
        &lt;/span&gt;
    &lt;/div&gt;;
}
}

const styles = StyleSheet.<span class="apidocCodeKeywordSpan">create</span>({
red: {
    backgroundColor: 'red'
},

blue: {
    backgroundColor: 'blue'
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheet.extend" id="apidoc.element.aphrodite.StyleSheet.extend">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>extend
        <span class="apidocSignatureSpan">(extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(extensions) {
    var extensionSelectorHandlers = extensions
    // Pull out extensions with a selectorHandler property
    .map(function (extension) {
        return extension.selectorHandler;
    })
    // Remove nulls (i.e. extensions without a selectorHandler
    // property).
    .filter(function (handler) {
        return handler;
    });

    return makeExports(useImportant, selectorHandlers.concat(extensionSelectorHandlers));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Aphrodite (`css`, `StyleSheet`, etc.) which will have your extensions included.
For example:

```js
// my-aphrodite.js
import {StyleSheet} from "aphrodite";

export default StyleSheet.<span class="apidocCodeKeywordSpan">extend</span>([extension1, extension2]);

// styled.js
import {StyleSheet, css} from "my-aphrodite.js";

const styles = StyleSheet.create({
    ...
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheet.rehydrate" id="apidoc.element.aphrodite.StyleSheet.rehydrate">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheet.</span>rehydrate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rehydrate() {
    var renderedClassNames /* : string[] */ = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];

    (0, _inject.addRenderedClassNames)(renderedClassNames);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        &lt;head&gt;
            &lt;style data-aphrodite&gt;${css.content}&lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id='root'&gt;${html}&lt;/div&gt;
            &lt;script src="./bundle.js"&gt;&lt;/script&gt;
            &lt;script&gt;
                StyleSheet.<span class="apidocCodeKeywordSpan">rehydrate</span>(${JSON.stringify(css.renderedClassNames)});
                ReactDOM.render(&lt;App/&gt;, document.getElementById('root'));
            &lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
`;
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.StyleSheetServer" id="apidoc.module.aphrodite.StyleSheetServer">module aphrodite.StyleSheetServer</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheetServer.renderStatic" id="apidoc.element.aphrodite.StyleSheetServer.renderStatic">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheetServer.</span>renderStatic
        <span class="apidocSignatureSpan">(renderFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function renderStatic(renderFunc) {
    (0, _inject.reset)();
    (0, _inject.startBuffering)();
    var html = renderFunc();
    var cssContent = (0, _inject.flushToString)();

    return {
        html: html,
        css: {
            content: cssContent,
            renderedClassNames: (0, _inject.getRenderedClassNames)()
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
As an example:

```js
import { StyleSheetServer } from 'aphrodite';

// Contains the generated html, as well as the generated css and some
// rehydration data.
var {html, css} = StyleSheetServer.<span class="apidocCodeKeywordSpan">renderStatic</span>(() =&gt; {
return ReactDOMServer.renderToString(&lt;App/&gt;);
});

// Return the base HTML, which contains your rendered HTML as well as a
// simple rehydration script.
return `
&lt;html&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.StyleSheetTestUtils" id="apidoc.module.aphrodite.StyleSheetTestUtils">module aphrodite.StyleSheetTestUtils</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheetTestUtils.clearBufferAndResumeStyleInjection" id="apidoc.element.aphrodite.StyleSheetTestUtils.clearBufferAndResumeStyleInjection">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheetTestUtils.</span>clearBufferAndResumeStyleInjection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearBufferAndResumeStyleInjection() {
    (0, _inject.reset)();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

describe('StyleSheetTestUtils.suppressStyleInjection', () =&gt; {
beforeEach(() =&gt; {
    StyleSheetTestUtils.suppressStyleInjection();
});

afterEach(() =&gt; {
    StyleSheetTestUtils.<span class="apidocCodeKeywordSpan">clearBufferAndResumeStyleInjection</span>();
});

it('allows css to be called without requiring a DOM', (done) =&gt; {
    const sheet = StyleSheet.create({
        red: {
            color: 'red',
        },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.StyleSheetTestUtils.suppressStyleInjection" id="apidoc.element.aphrodite.StyleSheetTestUtils.suppressStyleInjection">
        function <span class="apidocSignatureSpan">aphrodite.StyleSheetTestUtils.</span>suppressStyleInjection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function suppressStyleInjection() {
    (0, _inject.reset)();
    (0, _inject.startBuffering)();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    assert.include(ret.css.content, 'font-family:"My Font"');
    assert.include(ret.css.content, 'font-family:"My Font","My Other Font"');
});
});

describe('StyleSheetTestUtils.suppressStyleInjection', () =&gt; {
beforeEach(() =&gt; {
    StyleSheetTestUtils.<span class="apidocCodeKeywordSpan">suppressStyleInjection</span>();
});

afterEach(() =&gt; {
    StyleSheetTestUtils.clearBufferAndResumeStyleInjection();
});

it('allows css to be called without requiring a DOM', (done) =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.generate" id="apidoc.module.aphrodite.generate">module aphrodite.generate</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.generate.generateCSS" id="apidoc.element.aphrodite.generate.generateCSS">
        function <span class="apidocSignatureSpan">aphrodite.generate.</span>generateCSS
        <span class="apidocSignatureSpan">(selector, styleTypes, selectorHandlers, stringHandlers, useImportant )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateCSS(selector, styleTypes, selectorHandlers, stringHandlers, useImportant ) /* : string */{
    var merged /* : OrderedElements */ = styleTypes.reduce(_util.recursiveMerge, new _orderedElements2['default']());

    var plainDeclarations = new _orderedElements2['default']();
    var generatedStyles = "";

    // TODO(emily): benchmark this to see if a plain for loop would be faster.
    merged.forEach(function (key, val) {
        // For each key, see if one of the selector handlers will handle these
        // styles.
        var foundHandler = selectorHandlers.some(function (handler) {
            var result = handler(key, selector, function (newSelector) {
                return generateCSS(newSelector, [val], selectorHandlers, stringHandlers, useImportant);
            });
            if (result != null) {
                // If the handler returned something, add it to the generated
                // CSS and stop looking for another handler.
                generatedStyles += result;
                return true;
            }
        });
        // If none of the handlers handled it, add it to the list of plain
        // style declarations.
        if (!foundHandler) {
            plainDeclarations.set(key, val);
        }
    });

    return generateCSSRuleset(selector, plainDeclarations, stringHandlers, useImportant, selectorHandlers) + generatedStyles;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.generate.generateCSSRuleset" id="apidoc.element.aphrodite.generate.generateCSSRuleset">
        function <span class="apidocSignatureSpan">aphrodite.generate.</span>generateCSSRuleset
        <span class="apidocSignatureSpan">(selector, declarations, stringHandlers, useImportant, selectorHandlers )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateCSSRuleset(selector, declarations, stringHandlers, useImportant, selectorHandlers ) /* : string */{
    var handledDeclarations /* : OrderedElements */ = runStringHandlers(declarations, stringHandlers, selectorHandlers);

    var originalElements = _extends({}, handledDeclarations.elements);

    // NOTE(emily): This mutates handledDeclarations.elements.
    var prefixedDeclarations = prefixAll(handledDeclarations.elements);

    var prefixedRules = (0, _util.flatten)((0, _util.objectToPairs)(prefixedDeclarations).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var value = _ref2[1];

        if (Array.isArray(value)) {
            // inline-style-prefixer returns an array when there should be
            // multiple rules for the same key. Here we flatten to multiple
            // pairs with the same key.
            return value.map(function (v) {
                return [key, v];
            });
        }
        return [[key, value]];
    }));

    // Calculate the order that we want to each element in `prefixedRules` to
    // be in, based on its index in the original key ordering.
    var sortOrder = {};
    for (var i = 0; i &lt; handledDeclarations.keyOrder.length; i++) {
        var key = handledDeclarations.keyOrder[i];
        sortOrder[key] = i;

        // In order to keep most prefixed versions of keys in about the same
        // order that the original keys were in but placed before the
        // unprefixed version, we generate the prefixed forms of the keys and
        // set their order to the same as the original key minus a little bit.
        var capitalizedKey = '' + key[0].toUpperCase() + key.slice(1);
        var prefixedKeys = ['Webkit' + capitalizedKey, 'Moz' + capitalizedKey, 'ms' + capitalizedKey];
        for (var j = 0; j &lt; prefixedKeys.length; ++j) {
            if (!originalElements.hasOwnProperty(prefixedKeys[j])) {
                sortOrder[prefixedKeys[j]] = i - 0.5;
                originalElements[prefixedKeys[j]] = originalElements[key];
            }
        }
    }

    // Calculate the sort order of a given property.
    function sortOrderForProperty(_ref3) {
        var _ref32 = _slicedToArray(_ref3, 2);

        var key = _ref32[0];
        var value = _ref32[1];

        if (sortOrder.hasOwnProperty(key)) {
            if (originalElements.hasOwnProperty(key) &amp;&amp; originalElements[key] !== value) {
                // The value is prefixed. Sort this just before the key with
                // the unprefixed value.
                return sortOrder[key] - 0.25;
            } else {
                // Either the key and value are unprefixed here, or this is a
                // prefixed key. Either way, this is handled by the sortOrder
                // calculation above.
                return sortOrder[key];
            }
        } else {
            // If the property isn't in the sort order, it wasn't in the
            // original set of unprefixed keys, so it must be a prefixed key.
            // Sort at order -1 to put it at the top of the set of styles.
            return -1;
        }
    }

    // Actually sort the rules according to the sort order.
    prefixedRules.sort(function (a, b) {
        return sortOrderForProperty(a) - sortOrderForProperty(b);
    });

    var transformValue = useImportant === false ? _util.stringifyValue : function (key, value) {
        return (0, _util.importantify)((0, _util.stringifyValue)(key, value));
    };

    var rules = prefixedRules.map(function (_ref4) {
        var _ref42 = _slicedToArray(_ref4, 2);

        var key = _ref42[0];
        var value = _ref42[1];
        return (0, _util.kebabifyStyleName)(key) + ':' + transformValue(key, value) + ';';
    }).join("");

    if (rules) {
        return selector + '{' + rules + '}';
    } else {
        return "";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.inject" id="apidoc.module.aphrodite.inject">module aphrodite.inject</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.inject.addRenderedClassNames" id="apidoc.element.aphrodite.inject.addRenderedClassNames">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>addRenderedClassNames
        <span class="apidocSignatureSpan">(classNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addRenderedClassNames(classNames) {
    classNames.forEach(function (className) {
        alreadyInjected[className] = true;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.flushToString" id="apidoc.element.aphrodite.inject.flushToString">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>flushToString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flushToString() {
    isBuffering = false;
    var ret = injectionBuffer;
    injectionBuffer = "";
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.flushToStyleTag" id="apidoc.element.aphrodite.inject.flushToStyleTag">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>flushToStyleTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flushToStyleTag() {
    var cssContent = flushToString();
    if (cssContent.length &gt; 0) {
        injectStyleTag(cssContent);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.getRenderedClassNames" id="apidoc.element.aphrodite.inject.getRenderedClassNames">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>getRenderedClassNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRenderedClassNames() {
    return Object.keys(alreadyInjected);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.injectAndGetClassName" id="apidoc.element.aphrodite.inject.injectAndGetClassName">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>injectAndGetClassName
        <span class="apidocSignatureSpan">(useImportant, styleDefinitions, selectorHandlers )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function injectAndGetClassName(useImportant, styleDefinitions, selectorHandlers ) /* : string */{
    styleDefinitions = (0, _util.flattenDeep)(styleDefinitions);

    var classNameBits = [];
    var definitionBits = [];
    for (var i = 0; i &lt; styleDefinitions.length; i += 1) {
        // Filter out falsy values from the input, to allow for
        // `css(a, test &amp;&amp; c)`
        if (styleDefinitions[i]) {
            classNameBits.push(styleDefinitions[i]._name);
            definitionBits.push(styleDefinitions[i]._definition);
        }
    }
    // Break if there aren't any valid styles.
    if (classNameBits.length === 0) {
        return "";
    }
    var className = classNameBits.join("-o_O-");

    injectStyleOnce(className, '.' + className, definitionBits, useImportant, selectorHandlers);

    return className;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.injectStyleOnce" id="apidoc.element.aphrodite.inject.injectStyleOnce">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>injectStyleOnce
        <span class="apidocSignatureSpan">(key, selector, definitions, useImportant )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function injectStyleOnce(key, selector, definitions, useImportant ) {
    var selectorHandlers /* : SelectorHandler[] */ = arguments.length &lt;= 4 || arguments[4] === undefined ? [] : arguments[4];

    if (!alreadyInjected[key]) {
        var generated = (0, _generate.generateCSS)(selector, definitions, selectorHandlers, stringHandlers, useImportant);

        injectGeneratedCSSOnce(key, generated);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.reset" id="apidoc.element.aphrodite.inject.reset">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
    injectionBuffer = "";
    alreadyInjected = {};
    isBuffering = false;
    styleTag = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.inject.startBuffering" id="apidoc.element.aphrodite.inject.startBuffering">
        function <span class="apidocSignatureSpan">aphrodite.inject.</span>startBuffering
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startBuffering() {
    if (isBuffering) {
        throw new Error("Cannot buffer while already buffering");
    }
    isBuffering = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.no_important" id="apidoc.module.aphrodite.no_important">module aphrodite.no_important</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.no_important.css" id="apidoc.element.aphrodite.no_important.css">
        function <span class="apidocSignatureSpan">aphrodite.no_important.</span>css
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function css() /* : MaybeSheetDefinition[] */{
    for (var _len = arguments.length, styleDefinitions = Array(_len), _key = 0; _key &lt; _len; _key++) {
        styleDefinitions[_key] = arguments[_key];
    }

    return (0, _inject.injectAndGetClassName)(useImportant, styleDefinitions, selectorHandlers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.ordered_elements" id="apidoc.module.aphrodite.ordered_elements">module aphrodite.ordered_elements</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.ordered_elements.ordered_elements" id="apidoc.element.aphrodite.ordered_elements.ordered_elements">
        function <span class="apidocSignatureSpan">aphrodite.</span>ordered_elements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedElements() {
    var elements /* : {[string]: any} */ = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];
    var keyOrder /* : string[] */ = arguments.length &lt;= 1 || arguments[1] === undefined ? [] : arguments[1];

    _classCallCheck(this, OrderedElements);

    this.elements = elements;
    this.keyOrder = keyOrder;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.ordered_elements.from" id="apidoc.element.aphrodite.ordered_elements.from">
        function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>from
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (obj) {
    if (obj instanceof OrderedElements) {
        // NOTE(emily): This makes a shallow copy of the previous elements, so
        // if the elements are deeply modified it will affect all copies.
        return new OrderedElements(_extends({}, obj.elements), obj.keyOrder.slice());
    } else if (
    // For some reason, flow complains about a plain
    // `typeof Map !== "undefined"` check. Casting `Map` to `any` solves
    // the problem.
    typeof /*::(*/Map /*: any)*/ !== "undefined" &amp;&amp; obj instanceof Map) {
        return OrderedElements.fromMap(obj);
    } else {
        return OrderedElements.fromObject(obj);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	b /* : ObjectMap | Map&lt;string,any&gt; */
	) /* : OrderedElements | any */{
	    // TODO(jlfwong): Handle malformed input where a and b are not the same
	    // type.

	    if (!isPlainObject(a) || !isPlainObject(b)) {
	        if (isPlainObject(b)) {
	            return _orderedElements2['default'].<span class="apidocCodeKeywordSpan">from</span>(b);
	        } else {
	            return b;
	        }
	    }

	    var ret = _orderedElements2['default'].from(a);
	    var right = _orderedElements2['default'].from(b);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.ordered_elements.fromMap" id="apidoc.element.aphrodite.ordered_elements.fromMap">
        function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>fromMap
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromMap = function (map) {
    var ret = new OrderedElements();
    map.forEach(function (val, key) {
        ret.set(key, val);
    });
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	        // if the elements are deeply modified it will affect all copies.
	        return new OrderedElements(_extends({}, obj.elements), obj.keyOrder.slice());
	    } else if (
	    // For some reason, flow complains about a plain
	    // `typeof Map !== "undefined"` check. Casting `Map` to `any` solves
	    // the problem.
	    typeof /*::(*/Map /*: any)*/ !== "undefined" &amp;&amp; obj instanceof Map) {
	        return OrderedElements.<span class="apidocCodeKeywordSpan">fromMap</span>(obj);
	    } else {
	        return OrderedElements.fromObject(obj);
	    }
	};
	module.exports = exports["default"];

/***/ },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.ordered_elements.fromObject" id="apidoc.element.aphrodite.ordered_elements.fromObject">
        function <span class="apidocSignatureSpan">aphrodite.ordered_elements.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
    return new OrderedElements(obj, Object.keys(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	    } else if (
	    // For some reason, flow complains about a plain
	    // `typeof Map !== "undefined"` check. Casting `Map` to `any` solves
	    // the problem.
	    typeof /*::(*/Map /*: any)*/ !== "undefined" &amp;&amp; obj instanceof Map) {
	        return OrderedElements.fromMap(obj);
	    } else {
	        return OrderedElements.<span class="apidocCodeKeywordSpan">fromObject</span>(obj);
	    }
	};
	module.exports = exports["default"];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.aphrodite.util" id="apidoc.module.aphrodite.util">module aphrodite.util</a></h1>


    <h2>
        <a href="#apidoc.element.aphrodite.util.flatten" id="apidoc.element.aphrodite.util.flatten">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>flatten
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatten(list) {
    return (/* : any[] */list.reduce(function (memo, x) {
            return memo.concat(x);
        }, [])
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.flattenDeep" id="apidoc.element.aphrodite.util.flattenDeep">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>flattenDeep
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenDeep(list) {
    return (/* : any[] */list.reduce(function (memo, x) {
            return memo.concat(Array.isArray(x) ? flattenDeep(x) : x);
        }, [])
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.hashObject" id="apidoc.element.aphrodite.util.hashObject">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>hashObject
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hashObject(object) {
    return (/* : string */(0, _stringHash2['default'])(JSON.stringify(object)).toString(36)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.importantify" id="apidoc.element.aphrodite.util.importantify">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>importantify
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function importantify(string) {
    return (<span class="apidocCodeCommentSpan">/* : string */
</span>        // Bracket string character access is very fast, and in the default case we
        // normally don't expect there to be "!important" at the end of the string
        // so we can use this simple check to take an optimized path. If there
        // happens to be a "!" in this position, we follow up with a more thorough
        // check.
        string[string.length - 10] === '!' &amp;&amp; string.slice(-11) === ' !important' ? string : string + ' !important'
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.kebabifyStyleName" id="apidoc.element.aphrodite.util.kebabifyStyleName">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>kebabifyStyleName
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kebabifyStyleName(string) /* : string */{
    var result = string.replace(UPPERCASE_RE, UPPERCASE_RE_TO_KEBAB);
    if (result[0] === 'm' &amp;&amp; result[1] === 's' &amp;&amp; result[2] === '-') {
        return '-' + result;
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.mapObj" id="apidoc.element.aphrodite.util.mapObj">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>mapObj
        <span class="apidocSignatureSpan">(obj, fn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapObj(obj, fn ) /* : ObjectMap */{
    var keys = Object.keys(obj);
    var mappedObj = {};
    for (var i = 0; i &lt; keys.length; i += 1) {
        var _fn = fn([keys[i], obj[keys[i]]]);

        var _fn2 = _slicedToArray(_fn, 2);

        var newKey = _fn2[0];
        var newValue = _fn2[1];

        mappedObj[newKey] = newValue;
    }
    return mappedObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.objectToPairs" id="apidoc.element.aphrodite.util.objectToPairs">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>objectToPairs
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function objectToPairs(obj) {
    return (/* : Pairs */Object.keys(obj).map(function (key) {
            return [key, obj[key]];
        })
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.recursiveMerge" id="apidoc.element.aphrodite.util.recursiveMerge">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>recursiveMerge
        <span class="apidocSignatureSpan">(a, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recursiveMerge(a, b ) /* : OrderedElements | any */{
    // TODO(jlfwong): Handle malformed input where a and b are not the same
    // type.

    if (!isPlainObject(a) || !isPlainObject(b)) {
        if (isPlainObject(b)) {
            return _orderedElements2['default'].from(b);
        } else {
            return b;
        }
    }

    var ret = _orderedElements2['default'].from(a);
    var right = _orderedElements2['default'].from(b);

    right.forEach(function (key, val) {
        if (ret.has(key)) {
            ret.set(key, recursiveMerge(ret.get(key), val));
        } else {
            ret.set(key, val);
        }
    });

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.aphrodite.util.stringifyValue" id="apidoc.element.aphrodite.util.stringifyValue">
        function <span class="apidocSignatureSpan">aphrodite.util.</span>stringifyValue
        <span class="apidocSignatureSpan">(key, prop )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringifyValue(key, prop ) /* : string */{
    if (typeof prop === "number") {
        if (isUnitlessNumber[key]) {
            return "" + prop;
        } else {
            return prop + "px";
        }
    } else {
        return '' + prop;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>